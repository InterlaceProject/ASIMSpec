CoreASIM scheduler

use Standard

init Start
scheduling whileRunning

universe CLIENT = { START, CreditRequestClient, DebitRequestClient }
universe STATE = { SEND_CLIENT_MESSAGE, RECEIVE_CLIENT_MESSAGE, SCHEDULER_DONE }

controlled nextClient: CLIENT -> CLIENT
controlled currentClient: CLIENT
controlled state: STATE

controlled initBy: CLIENT -> FUNCTION
controlled withProg: CLIENT -> FUNCTION
controlled andPol: CLIENT -> FUNCTION

// not yet clear how asim scheduling works
policy whileRunning = {
	schedule server
	//if (temploc != undef) then schedule temploc
}

rule Start = {
	program(self) := Program
	nextClient(START) := CreditRequestClient
	currentClient := START
	state := SEND_CLIENT_MESSAGE
	
	nextClient(CreditRequestClient) := DebitRequestClient
	
	//CreditRequestClient
	initBy(CreditRequestClient) := InitCreditRequestClient
	withProg(CreditRequestClient) := ProgramCreditRequestClient
	andPol(CreditRequestClient) := SkipCreditRequestClient
	
	//DebitRequestClient
	initBy(DebitRequestClient) := InitDebitRequestClient
	withProg(DebitRequestClient) := ProgramDebitRequestClient
	andPol(DebitRequestClient) := SkipDebitRequestClient
}

//-----------------------------------------------------------------------------------------------------------
//				begin scheduler main programm
//-----------------------------------------------------------------------------------------------------------
rule Program = local clientName, temploc in seq
	//wait a little before first client to spawn
	if stepcount >= 15 and state = SEND_CLIENT_MESSAGE then seq
		currentClient := nextClient(currentClient)
		//Client rules are defined in clientTemplate script
		if currentClient != undef then seq
			createASIM currentClient 
				initializedBy initBy(currentClient)
				withProgram withProg(currentClient)
				andPolicy andPol(currentClient)
				in temploc
				
			state := RECEIVE_CLIENT_MESSAGE
		endseq
		else state := SCHEDULER_DONE
		
		print "state:: " + toString(state)
	endseq
	
	if state = RECEIVE_CLIENT_MESSAGE then
		//look into inbox if a client has been sent its message and could be destroyed
		choose m in inboxOf(self) with getMessageSubject(m)="Done" do seq
			clientName := getMessageSender(m)
			destroyASIM clientName
			temploc := undef
			print "--------------------------------------------------------------------------"
			print "client removed: " + clientName
			state := SEND_CLIENT_MESSAGE
		endseq
endseq