CoreASIM server

use TurboASMPlugin
use ConditionalRule
use Standard

init Start

policy whileRunning = skip
scheduling whileRunning

universe ACCOUNT_TYPES = { CC, DOMU, MIRROR, Income, Prepaid, Bisoo, Topup }
universe OPERATION = { credit, debit }
universe UNIT = {SRD, EUR}
universe USER_TYPE_GROUP = { 
								welcome,
								retail,
								company,
								full,
								employee,
								on_hold,
								MNGR,
								consumer,
								consumer_verified
							}
universe CHANNEL = { Service, POS }

universe MESSAGE_REQUESTS = {
								CreditReviewReq,
								CreditPerformReq,
								DebitPreviewReq,
								DebitPerformReq,
								DebitAckExec,
								ProceedMessage,
								DoNotProceedMessage,
								TransferPerformed,
								ConfirmationReq
							}

universe ACCOUNT_ID = {accId1, accId2, accId3}
universe MEMBER_ID = {mbrId1, mbrId2, mbrId3}

controlled profileTable: MEMBER_ID -> MAP
controlled accountTable: ACCOUNT_ID -> MAP
controlled userGroupTable: MEMBER_ID -> USER_TYPE_GROUP
controlled TT: OPERATION * UNIT * USER_TYPE_GROUP -> SET
controlled accountConnectivity: OPERATION * UNIT * ACCOUNT_TYPES -> SET
//controlled sessionData: STRING -> STRING
controlled sessionData: MAP

controlled Ledger: MAP

//-----------------------------------------------------------------------------------------------------------
//				begin tiny logger (because debug logger of ASM-Plugin is laborious to use)
//-----------------------------------------------------------------------------------------------------------
universe LOG_LEVEL = {FATAL, ERROR, WARN, INFO, DEBUG} //all log levels
controlled current_log_level: LOG_LEVEL //current log leve
controlled log_states: SET  //list of states which should be written to the log

rule initCustomLogger(set_log_level) = seq
	//TODO: add log to file option?
	current_log_level := set_log_level
	log_states := {FATAL}
	
	if set_log_level = ERROR then
		log_states := {FATAL, ERROR}
	if set_log_level = WARN then
		log_states := {FATAL, ERROR, WARN}
	if set_log_level = INFO then
		log_states := {FATAL, ERROR, WARN, INFO}
	if set_log_level = DEBUG then
		log_states := {FATAL, ERROR, WARN, INFO, DEBUG}
	
	do_log("LOG_LEVEL: " + current_log_level + ", LOG STATES: " + log_states, DEBUG)
endseq

rule do_log(text, level) = local write_log in seq
	//strangely "= true" needs to be placed
	//otherwise the if-statement fails
	if (level memberof log_states) = true then
		print level + ": " + text
endseq

//-----------------------------------------------------------------------------------------------------------
//				begin globally used rules
//-----------------------------------------------------------------------------------------------------------
rule Start = {
	do_log("ASIM MUTUAL CREDIT server init", INFO)
	
	Ledger := {->}
	
	//defined in initaccounts.casim
	InitData()
	
	//initalize logger
	initCustomLogger(DEBUG)
	
	program(self) := Program
}

//read value from a map (amap) identified by a key
derived v(amap, key) =
	return ret in
		if amap = undef then
			ret := undef
		else
			choose v in amap with key = nth(v, 1) do ret := nth(v, 2)



derived messageContent(msg) =
	return content in
		content := nth(msg, 1)

derived messageSubject(msg) =
	return ms in
		ms := nth(msg, 2)

// send message to receipient mbr
rule Send(msg, mbr) = {
	send messageContent(msg) to mbr with subject messageSubject(msg)
}

// not permitted message
derived NotPermitted(transfer, error) =
	return message in
		message := AssembleMessage(error + " for transfer: " + transfer, toString(DoNotProceedMessage))

//prepare normal message
derived YouMayProceedWith(transfer) =
	return message in
		message := AssembleMessage(transfer, toString(ProceedMessage))

//success message with optional limitAlert
derived TransferPerformedSuccessfully(transfer, limitAlert) =
	return message in
		if limitAlert = undef then
			message := AssembleMessage(transfer + " performed successfully", toString(TransferPerformed))
		else
			message := AssembleMessage(transfer + " performed successfully with alert " + limitAlert,
						toString(TransferPerformed))
						
//put message together with subject
derived AssembleMessage(msg, sub) =
	return message in
		message := [msg, sub]

//check the balances
//maybe derived function instead of returning rule
//amount condition check missing (D2.1)
derived balanceCheck(fromAccount, toAccount, amount) =
	return message in
		if (fromAccount = undef or toAccount = undef or amount = undef) then
			message := "Message format incorrect"
		else
			if availableBalance(fromAccount) >= amount and Receivable(amount, toAccount) then
				message := "OK"
			else if availableBalance(fromAccount) < amount then
				message := "ViolatesLowerLimit"
			else if not Receivable(amount, toAccount) then
				message := "ViolatesUpperLimit"
			else //what todo in that case
				message := "Unknown State"

//receivable for to-account
derived Receivable(amt, acc) =
	return pass in
		pass := ((balance(acc) + amt) <= upperLimit(acc))

//get balance for account	
derived balance(acc) =
	return bal in
		bal := v(acc, "balance")
		
//get account upper limit
derived upperLimit(acc) =
	return ul in
		ul := v(acc, "upperLimit")
		
//get credit limit
derived creditLimit(acc) =
	return cl in
		cl :=  v(acc, "creditLimit")
		
//get from account
derived fromAcc(transfer) =
	return fa in
		fa :=  v(transfer, "from") 

//get from account
derived toAcc(transfer) =
	return fa in
		fa :=  v(transfer, "from") 

//return amount
derived amountOf(transfer) =
	return a in
		a := v(transfer, "amount")
		
//get debitor member id of a transfer
derived debitorOf(transfer) =
	return mbrId in
		mbrId := v(transfer, "debitor")


//calualte avaiable balance by using the account
derived availableBalance(account) =
	return availBal in
		availBal := balance(account) + creditLimit(account)

//get account set by id		
derived accountOf(accId) =
	return ac in
		ac := accountTable(accId)

//get unit of account id
derived unitOf(accId) =
	return unit in
		unit := v(accountOf(accId), "unit")

//get account type of account id
derived accountType(accId) =
	 return type in
	 	type := v(accountOf(accId), "accountType")

//get owner of account
derived ownerOf(accId) =
	return owner in
		owner := v(accountOf(accId), "MemberID")

//get profile of member
derived profileOf(mbrId) =
	return profile in
		profile := profileTable(mbrId)

//get group of member by id
derived groupOf(mbrId) =
	return group in
		group := userGroupTable(mbrId)

//get member id by using session information
derived activeLogin(client) =
	return mbrId in
		forall session in sessionData do
			if client = nth(session, 1) then
				mbrId := nth(session, 2)
				
//get client id by using session information
derived activeClient(login_mbrId) =
	return client in
		choose session in sessionData with login_mbrId = nth(session, 2) do
				client := nth(session, 1)

derived memberAccounts(profile) =
	return aL in
		aL := profile("accounts")

//get credit account
derived creditAccount(mbrId) =
	return accId in
		if memberAccounts(profileOf(mbrId)) = undef then
			accId := undef
		else
			forall acc in memberAccounts(profileOf(mbrId)) do
				if ownerOf(acc) = mbrId and accountType(acc) = "CC"  then
					accId := acc
				
//fake transaction id
derived NewTransactionID(len) =
	return tID in seq
		tID := ""
		while (|tID| < len) tID := tID + RandomHex()
	endseq

//get random hex number
derived RandomHex =
	return hex in
		choose n in ["0", "1", "2", "3", "4", 
					 "5", "6", "7", "8", "9", 
					 "a", "b", "c", "d", "e", "f"] do hex := n

//read transaction id
derived idOf(trans) =
	return id in
		id := v(trans, "id")

//create transaction for ledger
derived Transaction(transfer, mbr, operation, limitAlert, date) =
	return t in
		t := {
			"transfer" -> transfer,
			"alert" -> limitAlert,
			"date" -> date,
			"member" -> mbr,
			"operation" -> operation
		}		

//append transaction
rule Append(trans, ledger) = 
local transactionId in seq
	transactionId := NewTransactionID(16)
	add { transactionId -> trans } to ledger
	
	do_log(ledger, DEBUG)
endseq

//check for "small" amount
derived Small(amount) =
	return small in
		small := (amount < 100)

//test if an one time pad has been expired		
derived Expired(otp) = 
	return expired in
		expired := ((now - birthtime(otp)) > lifetimeForOTPs)
			

//check alert limits
//  checked after current transfer has
//  been performed on the ledger
derived CheckAccountLimitsAlerts(profile, account) =
	return alert in
		if ((creditLimit(account) + balance(account)) < v(profile, "lowBalanceAlert")) then
			alert := "LowBalanceAlert"
		else if ((upperLimit(account) - balance(account)) < v(profile, "highBalanceAlert")) then
			alert := "HighBalanceAlert"
		else if ((v(profile, "capacity") - v(profile, "saleVolume")) < v(profile, "highVolumeAlert")) then
			alert := "HighVolumeAlert"
		else 
			alert := undef
			
// check for a credit request
// might be party separated for the debit check (similar requirements?)
rule PreviewCheck(fromUnit, toUnit, fromGrpId, toGrpId, fromAccountType, toAccountType, operation) =
local errormessage, tt, ac in seq
	errormessage := undef
	
	// checks begin	
	if (fromUnit = toUnit) then seq // unit check - optional
		do_log("units are equal", DEBUG)
		
		tt := TT("credit", fromUnit, fromGrpId)
		do_log("TT -> " + tt, DEBUG)
		
		if (toGrpId memberof tt) then seq //TT check
			do_log("group in TT", DEBUG)
			
			ac := accountConnectivity(operation, fromUnit, fromAccountType) 
			do_log("AC -> " + ac, DEBUG)
			
			if (toAccountType memberof ac) then //account connectivity test
				do_log("accounts compatible", DEBUG)
			else errormessage := "accounts not compatible"
		endseq
		else errormessage := "group NOT in TT"
	endseq
	else errormessage := "Units mismatch"
	
	result := errormessage
endseq

//-----------------------------------------------------------------------------------------------------------
//				begin CreditPreviewReq
//-----------------------------------------------------------------------------------------------------------

rule HandleCreditPreviewReq(transfer, mbr) = 
	local error in seq
	do_log(mbr + " -> CreditPreviewReq received: " + transfer, INFO)
	
	//do check the transfer if is ok
	error <- PreviewCheck(
		unitOf(fromAcc(transfer)),
		unitOf(toAcc(transfer)),
		groupOf(ownerOf(fromAcc(transfer))),
		groupOf(ownerOf(toAcc(transfer))),
		accountType(fromAcc(transfer)),
		accountType(toAcc(transfer)),
		"credit")
	
	//communicate status
	//if seq block is removed send is not performed
	if (error = undef) then seq
		Send(YouMayProceedWith(transfer), mbr)
	endseq 
	else seq
		Send(NotPermitted(transfer, error), mbr)
	endseq
endseq

//-----------------------------------------------------------------------------------------------------------
//				begin CreditPerformReq
//-----------------------------------------------------------------------------------------------------------
rule HandleCreditPerformReq(transfer, mbr) = 
local limitAlert, bC, error in seq
	do_log(mbr + " -> CreditPerformReq received: " + transfer, INFO)	
	
	//do check the transfer if still ok
	error <- PreviewCheck(
		unitOf(fromAcc(transfer)),
		unitOf(toAcc(transfer)),
		groupOf(ownerOf(fromAcc(transfer))),
		groupOf(ownerOf(toAcc(transfer))),
		accountType(fromAcc(transfer)),
		accountType(toAcc(transfer)),
		"credit")

	if (error != undef) then seq
		Send(NotPermitted(transfer, error), mbr)
	endseq
	else seq
		bC := balanceCheck(
			accountOf(fromAcc(transfer)),
			accountOf(toAcc(transfer)),
			amountOf(transfer))

		if bC = "OK" then seq
		
			do_log("balance check passed: performing credit transfer!", INFO)		
			
			limitAlert := CheckAccountLimitsAlerts(
				profileOf(ownerOf(fromAcc(transfer))),
				accountOf(fromAcc(transfer)))
			
			if (limitAlert = undef) then
				do_log("No limit alert", DEBUG)
			else
				do_log("Limit alert: " + limitAlert, WARN)
		
			//finally performing transfer by appending to the current ledger
			Append(Transaction(transfer, mbr, "credit", limitAlert, now), Ledger)
			
			//send success message, attach limitAlert if necessary
			Send(TransferPerformedSuccessfully(transfer, limitAlert), mbr)
			
			skip
		endseq
		else seq
			Send(NotPermitted(transfer, "Balance check problem: " + bC), mbr)
		endseq
	endseq
	
endseq

//-----------------------------------------------------------------------------------------------------------
//				begin DebitPreviewReq
//-----------------------------------------------------------------------------------------------------------
rule HandleDebitPreviewReq(transfer, mbr) = seq
	do_log(creditor + " -> DebitPreviewReq received: " + transfer, INFO)
	do_log(creditor + " -> login name: " + creditor, DEBUG)
	do_log(creditor + " -> profile: " + profileOf(creditor), DEBUG)
	do_log(creditor + " -> accounts: " + memberAccounts(profileOf(creditor)), DEBUG)
	do_log(creditor + " -> creditAccount: " + creditAccount(creditor), DEBUG)
	
	//debitor=buyer 
	fromA := creditAccount(debitorOf(transfer))
	//get login information
	creditor := activeLogin(mbr)
	//creditor=seller
	toA := creditAccount(activeLogin(mbr))
	do_log("from Account:: "+ fromA, DEBUG)
	do_log("to Account::" + toA, DEBUG)
	
	//do check the transfer if still ok
	error <- PreviewCheck(
		unitOf(fromA),
		unitOf(toA),
		//fromGroup and toGroup are both from the seller/creditor
		groupOf(creditor),
		groupOf(creditor),
		accountType(fromA),
		accountType(toA),
		"debit")
	
	do_log("PreviewCheck:: " + error, DEBUG)
	
	//communicate status
	//if seq block is removed send is not performed
	if (error = undef) then seq
		Send(YouMayProceedWith(transfer), mbr)
	endseq 
	else seq
		Send(NotPermitted(transfer, error), mbr)
	endseq
endseq

//-----------------------------------------------------------------------------------------------------------
//				begin DebitPerformReq
//-----------------------------------------------------------------------------------------------------------
rule HandleDebitPerformReq(transfer, mbr) = seq
	do_log(mbr + " -> DebitPerformReq received:: " + transfer, INFO)
	
	
	//debitor=buyer 
	fromA := creditAccount(debitorOf(transfer))
	//get login information
	creditor := activeLogin(mbr)
	//creditor=seller
	toA := creditAccount(activeLogin(mbr))
	
	do_log(creditor + " -> login name: " + creditor, DEBUG)
	do_log(creditor + " -> profile: " + profileOf(creditor), DEBUG)
	do_log(creditor + " -> accounts: " + memberAccounts(profileOf(creditor)), DEBUG)
	do_log(creditor + " -> creditAccount: " + creditAccount(creditor), DEBUG)
	
	do_log("from Account:: "+ fromA, DEBUG)
	do_log("to Account::" + toA, DEBUG)
	
	//re-do check the transfer if still ok
	error <- PreviewCheck(
		unitOf(fromA),
		unitOf(toA),
		//fromGroup and toGroup are both from the seller/creditor
		groupOf(creditor),
		groupOf(creditor),
		accountType(fromA),
		accountType(toA),
		"debit")
	
	do_log("PreviewCheck:: " + error, DEBUG)
	
	if (error != undef) then seq
		do_log("error:: " + error, DEBUG)
		Send(NotPermitted(transfer, error), mbr)
	endseq
	else seq
		bC := balanceCheck(accountOf(fromA), accountOf(toA), amountOf(transfer))		
		
		//do_log("blanace from:: " + balance(accountOf(fromA)), DEBUG)
		//do_log("blanace to:: " + balance(accountOf(toA)), DEBUG)
		do_log("bC:: " + bC, DEBUG)
		
		if bC = "OK" then seq
		
			limitAlert := CheckAccountLimitsAlerts(
				profileOf(ownerOf(fromA)),
				accountOf(fromA))
			
			if (limitAlert = undef) then
				do_log("No limit alert", DEBUG)
			else
				do_log("Limit alert: " + limitAlert, WARN)
				
			if Small(amountOf(transfer)) then seq
				do_log("balance check passed: performing debit transfer for small amount!", INFO)		
		
				//finally performing transfer by appending to the current ledger
				Append(Transaction(transfer, mbr, "debit", limitAlert, now), Ledger)
				
				//send success message, attach limitAlert if necessary
				Send(TransferPerformedSuccessfully(transfer, limitAlert), activeClient(creditor)) //send to creditor
				Send(TransferPerformedSuccessfully(transfer, limitAlert), activeClient(debitorOf(transfer))) //TODO: send to debitor
			endseq
			else seq
				do_log(mbr + " -> debit OTP TODO", DEBUG)
			endseq
		endseq
		else seq
			Send(NotPermitted(transfer, "Balance check problem: " + bC), mbr)
		endseq
	endseq
endseq

//-----------------------------------------------------------------------------------------------------------
//				begin DebitPerformReq
//-----------------------------------------------------------------------------------------------------------
rule HandleDebitAckExec(transfer, mbr) = {
	do_log(mbr + " -> DebitAckExec received" + transfer, INFO)
}

//-----------------------------------------------------------------------------------------------------------
//				begin main programm
//-----------------------------------------------------------------------------------------------------------
rule Program = {
	forall m in inboxOf(self) do seq
		//fetch message information
		msubject := getMessageSubject(m)
		msgIn := getMessageContent(m)
		member := getMessageSender(m)
		
		do_log("message received from " + member + " with subject " + msubject , DEBUG)
		
		//dispatch messages
    	if msgIn != undef and member != undef then seq
    		if msubject = toString(CreditReviewReq) then HandleCreditPreviewReq(msgIn, member)
    		if msubject = toString(CreditPerformReq) then HandleCreditPerformReq(msgIn, member)
    		if msubject = toString(DebitPreviewReq) then HandleDebitPreviewReq(msgIn, member)
    		if msubject = toString(DebitPerformReq) then HandleDebitPerformReq(msgIn, member)
    		if msubject = toString(DebitAckExec) then HandleDebitAckExec(msgIn, member)
		endseq
    endseq
}