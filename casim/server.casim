CoreASIM server

use TurboASMPlugin
use Standard

init Start

scheduling whileRunning

universe ACCOUNT_TYPES = { CC, DOMU, MIRROR, Income, Prepaid, Bisoo, Topup }
universe OPERATION = { credit, debit }
universe UNIT = {SRD, EUR}
universe USER_TYPE_GROUP = { welcome, retail, company, full, employee, on_hold, MNGR, consumer, consumer_verified }
universe CHANNEL = { Service, POS }

universe ACCOUNT_ID = {accId1, accId2}
universe MEMBER_ID = {mbrId1, mbrId2}

controlled profileTable: MEMBER_ID -> MAP
controlled accountTable: ACCOUNT_ID -> MAP
controlled userGroupTable: MEMBER_ID -> USER_TYPE_GROUP
controlled TT: OPERATION * UNIT * USER_TYPE_GROUP -> SET
controlled accountConnectivity: OPERATION * UNIT * ACCOUNT_TYPES -> SET

policy whileRunning = skip

rule Start = {
	print "ASIM MUTUAL CREDIT server init"
	
	//defined in initaccounts.casim
	InitData()
	
	program(self) := Program
}
//-----------------------------------------------------------------------------------------------------------
//				begin globally used rules
//-----------------------------------------------------------------------------------------------------------
//read value from a map (amap) identified by a key
derived v(amap, key) =
	return ret in
		choose v in amap with key = nth(v, 1) do ret := nth(v, 2)

// not permitted message
rule NotPermitted(transfer, error, mbr) = {
	send error + " for transfer: " + transfer to mbr with subject "DoNotProceedMessage"
}

//prepare normal message
rule YouMayProceedWith(transfer, mbr) = {
	send transfer to mbr with subject "ProceedMessage"
}

//send error status to member
rule SendStatus(transfer, error, mbr) = {
	if (error != undef) then seqblock
		// send DoNotProceedMessage if error detected
		NotPermitted(transfer, error, mbr)
	endseqblock
	else seqblock
		// send ProceedMessage if no error occured
		YouMayProceedWith(transfer, mbr)
	endseqblock
}
//-----------------------------------------------------------------------------------------------------------
//				begin CreditPreviewReq
//-----------------------------------------------------------------------------------------------------------

rule CreditPreviewReq(transfer, mbr) = local error in seqblock
	print mbr + " -> CreditPreviewReq received: " + transfer
	
	//do check the transfer
	error <- CreditPreviewCheck(transfer, mbr)
	
	//communicate status
	SendStatus(transfer, error, mbr)
endseqblock

//check the balances
//maybe derived function instead of returning rule
derived balanceCheck(fromAccount, toAccount, amount) =
	return message in
		message := "OK"

//check alert limits
//  checked after current transfer has
//  been performed on the ledger
derived CheckAccountLimitsAlerts(profile, account) =
	return alert in
		if ((v(account, "creditLimit") + v(account, "balance")) < v(profile, "lowBalanceAlert")) then
			alert := "LowBalanceAlert"
		else if ((v(account, "upperLimit") - v(account, "balance")) < v(profile, "highBalanceAlert")) then
			alert := "HighBalanceAlert"
		else if ((v(profile, "capacity") - v(profile, "saleVolume")) < v(profile, "highVolumeAlert")) then
			alert := "HighVolumeAlert"
		else 
			alert := undef
			
// check for a credit request
// might be party separated for the debit check (similar requirements?)
rule CreditPreviewCheck(transfer, mbr) =
	local errormessage, tt, ac, amount, 
				fromAccID, fromAccount, fromMbrId, fromGrpId, fromUnit, fromAccountType,
				toAccID, toAccount, toMbrId, toGrpId, toUnit, toAccountType, limitAlert, hasCorrectBlance in
seqblock
	errormessage := undef
	
	// read from properties
	fromAccID := v(transfer, "from")
	print "fromAccID -> " + fromAccID
	fromAccount := accountTable(fromAccID)
	print "fromAccount -> " + fromAccount
	fromMbrId := v(fromAccount, "MemberID")
	print "fromMbrId -> " + fromMbrId
	fromGrpId := userGroupTable(fromMbrId)
	print "fromGrpId -> " + fromGrpId
	fromUnit := v(fromAccount, "unit")
	print "fromUnit -> " + fromUnit
	fromAccountType := v(fromAccount, "accountType")
	print "fromAccountType -> " + fromAccountType
	
	//read to properties
	toAccID := v(transfer, "to")
	print "toAccID -> " + toAccID
	toAccount := accountTable(toAccID)
	print "toAccount -> " + toAccount
	toMbrId := v(toAccount, "MemberID")
	print "toMbrId -> " + toMbrId
	toGrpId := userGroupTable(toMbrId)
	print "toGrpId -> " + toGrpId
	toUnit := v(toAccount, "unit")
	print "toUnit -> " + toUnit
	toAccountType := v(toAccount, "accountType")
	print "toAccountType -> " + toAccountType
	//TODO: raise error on missing information
	
	// checks begin -------------------------------
	// unit check - optional
	if (fromUnit = toUnit) then seqblock
		print "---- units are equal ----"
		
		tt := TT("credit", fromUnit, fromGrpId)
		print "TT -> " + tt
		
		//TT check
		if (toGrpId memberof tt) then seqblock
			print "---- group in TT ----"
			
			ac := accountConnectivity("credit", fromUnit, fromAccountType) 
			print "AC -> " + ac
			
			//account connectivity test
			if (toAccountType memberof ac) then
				print "---- accounts connected ----"
			else errormessage := "accounts not connected"
		endseqblock
		else errormessage := "group NOT in TT"
	endseqblock
	else errormessage := "Units mismatch"
	
	result := errormessage
endseqblock

//-----------------------------------------------------------------------------------------------------------
//				begin CreditPerformReq
//-----------------------------------------------------------------------------------------------------------
rule CreditPerformReq(transfer, mbr) = 
local error, fromAccID, fromAccount, fromMbrId, fromProfile, limitAlert in seqblock
	print mbr + " -> CreditPerformReq received: " + transfer
	
	//do check the transfer if still ok
	error <- CreditPreviewCheck(transfer, mbr)

	if (error != undef) then
		NotPermitted(transfer, error, mbr)
	else seq
		bC := balanceCheck(v(transfer, "from"), v(transfer, "to"), amount)
		
		if bC = "OK" then seqblock
			print "---- balance check passed: performing transfer ---"
			
			//TODO: perform transfer
			
			fromAccID := v(transfer, "from")
			fromAccount := accountTable(fromAccID)
			fromMbrId := v(fromAccount, "MemberID")
			fromProfile := profileTable(fromMbrId)
			print "CreditPerformReq: " + "from: " + fromAccID + ", fromMbrId: " + fromMbrId
			
			limitAlert := CheckAccountLimitsAlerts(fromProfile, fromAccount)
			print "Limit Alert: " + limitAlert
			
			print "CreditPerformReq fromAccID: " + fromAccID
		endseqblock
		else NotPermitted(transfer, "Balance check problem: " + bC, mbr)
	endseq	
endseqblock
//-----------------------------------------------------------------------------------------------------------
//				begin DebitPreviewReq
//-----------------------------------------------------------------------------------------------------------
rule DebitPreviewReq(transfer, mbr) = {
	print mbr + " -> DebitPreviewReq received" + transfer
}

//-----------------------------------------------------------------------------------------------------------
//				begin DebitPerformReq
//-----------------------------------------------------------------------------------------------------------
rule DebitPerformReq(transfer, mbr) = {
	print mbr + " -> DebitPerformReq received" + transfer
}

//-----------------------------------------------------------------------------------------------------------
//				begin main programm
//-----------------------------------------------------------------------------------------------------------
rule Program = {
	forall m in inboxOf(self) do seqblock
		print "message received"
		//fetch message data
		msubject := getMessageSubject(m)
		msgIn := getMessageContent(m)
		member := getMessageSender(m)
		
    	if msgIn != undef and member != undef then seqblock
    		if msubject = "CreditReviewRequest" then CreditPreviewReq(msgIn, member)
    		if msubject = "CreditPerformReq" then CreditPerformReq(msgIn, member)
    		if msubject = "DebitPreviewReq" then DebitPreviewReq(msgIn, member)
    		if msubject = "DebitPerformReq" then DebitPerformReq(msgIn, member)
		endseqblock
    endseqblock
}