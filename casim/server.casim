CoreASIM server

use TurboASMPlugin
use Standard

init Start

scheduling whileRunning

universe ACCOUNT_TYPES = { CC, DOMU, MIRROR, Income, Prepaid, Bisoo, Topup }
universe OPERATION = { credit, debit }
universe UNIT = {SRD, EUR}
universe USER_TYPE_GROUP = { welcome, retail, company, full, employee, on_hold, MNGR, consumer, consumer_verified }
universe CHANNEL = { Service, POS }

universe ACCOUNT_ID = {accId1, accId2}
universe MEMBER_ID = {mbrId1, mbrId2}

controlled profileTable: MEMBER_ID -> MAP
controlled accountTable: ACCOUNT_ID -> MAP
controlled userGroupTable: MEMBER_ID -> USER_TYPE_GROUP
controlled TT: OPERATION * UNIT * USER_TYPE_GROUP -> SET
controlled accountConnectivity: OPERATION * UNIT * ACCOUNT_TYPES -> SET

policy whileRunning = skip

rule Start = {
	print "ASIM MUTUAL CREDIT server init"
	
	//defined in initaccounts.casim
	InitData()
	
	program(self) := Program
}
//-----------------------------------------------------------------------------------------------------------
//				begin globally used rules
//-----------------------------------------------------------------------------------------------------------
//read value from a map (amap) identified by a key
derived v(amap, key) =
	return ret in
		choose v in amap with key = nth(v, 1) do ret := nth(v, 2)

derived messageContent(msg) =
	return content in
		content := nth(msg, 1)

derived messageSubject(msg) =
	return ms in
		ms := nth(msg, 2)

rule Send(msg, mbr) = {
	send messageContent(msg) to mbr with subject messageSubject(msg)
}

// not permitted message
derived NotPermitted(transfer, error) =
	return message in
		message := [error + " for transfer: " + transfer, "DoNotProceedMessage"]

//prepare normal message
derived YouMayProceedWith(transfer) =
	return message in
		message := [transfer, "ProceedMessage"]

//success message with optional limitAlert
derived TransferPerformedSuccessfully(transfer, limitAlert) =
	return message in
		if limitAlert = undef then
			message := [transfer + " performed successfully", "TransferPerformed"]
		else
			message := [transfer + " performed successfully with alert " + limitAlert,
						"TransferPerformed"]

//-----------------------------------------------------------------------------------------------------------
//				begin CreditPreviewReq
//-----------------------------------------------------------------------------------------------------------

rule CreditPreviewReq(transfer, mbr) = local error in seqblock
	print mbr + " -> CreditPreviewReq received: " + transfer
	
	//do check the transfer
	error <- CreditPreviewCheck(transfer, mbr)
	
	//communicate status
	if (error != undef) then seqblock
		Send(NotPermitted(transfer, error), mbr)
	endseqblock
	else seqblock
		Send(YouMayProceedWith(transfer), mbr)
	endseqblock
endseqblock

//check the balances
//maybe derived function instead of returning rule
//amount condition check missing (D2.1)
derived balanceCheck(fromAccount, toAccount, amount) =
	return message in
		if availableBalance(fromAccount) >= amount  and Receivable(amount, toAccount) then
			message := "OK"
		else if availableBalance(fromAccount) < amount then
			message := "ViolatesLowerLimit"
		else if not Receivable(amount, toAccount) then
			message := "ViolatesUpperLimit"
		else //what todo in that case
			message := "UnknownState"

// reveivable for to-account
derived Receivable(amt, acc) =
	return pass in
		pass := ((v(acc, "balance") + amt) <= v(acc, "upperLimit"))

// calualte avaiable balance by using the account
derived availableBalance(account) =
	return availBal in
		availBal := v(account, "balance") + v(account, "creditLimit")

//check alert limits
//  checked after current transfer has
//  been performed on the ledger
derived CheckAccountLimitsAlerts(profile, account) =
	return alert in
		if ((v(account, "creditLimit") + v(account, "balance")) < v(profile, "lowBalanceAlert")) then
			alert := "LowBalanceAlert"
		else if ((v(account, "upperLimit") - v(account, "balance")) < v(profile, "highBalanceAlert")) then
			alert := "HighBalanceAlert"
		else if ((v(profile, "capacity") - v(profile, "saleVolume")) < v(profile, "highVolumeAlert")) then
			alert := "HighVolumeAlert"
		else 
			alert := undef
			
// check for a credit request
// might be party separated for the debit check (similar requirements?)
rule CreditPreviewCheck(transfer, mbr) =
	local errormessage, tt, ac, amount, 
				fromAccID, fromAccount, fromMbrId, fromGrpId, fromUnit, fromAccountType,
				toAccID, toAccount, toMbrId, toGrpId, toUnit, toAccountType, limitAlert, hasCorrectBlance in
seqblock
	errormessage := undef
	
	// read from properties
	fromAccID := v(transfer, "from")
	print "fromAccID -> " + fromAccID
	fromAccount := accountTable(fromAccID)
	print "fromAccount -> " + fromAccount
	fromMbrId := v(fromAccount, "MemberID")
	print "fromMbrId -> " + fromMbrId
	fromGrpId := userGroupTable(fromMbrId)
	print "fromGrpId -> " + fromGrpId
	fromUnit := v(fromAccount, "unit")
	print "fromUnit -> " + fromUnit
	fromAccountType := v(fromAccount, "accountType")
	print "fromAccountType -> " + fromAccountType
	
	//read to properties
	toAccID := v(transfer, "to")
	print "toAccID -> " + toAccID
	toAccount := accountTable(toAccID)
	print "toAccount -> " + toAccount
	toMbrId := v(toAccount, "MemberID")
	print "toMbrId -> " + toMbrId
	toGrpId := userGroupTable(toMbrId)
	print "toGrpId -> " + toGrpId
	toUnit := v(toAccount, "unit")
	print "toUnit -> " + toUnit
	toAccountType := v(toAccount, "accountType")
	print "toAccountType -> " + toAccountType
	
	//TODO: raise error on missing information
	
	// checks begin -------------------------------
	// unit check - optional
	if (fromUnit = toUnit) then seqblock
		print "---- units are equal ----"
		
		tt := TT("credit", fromUnit, fromGrpId)
		print "TT -> " + tt
		
		//TT check
		if (toGrpId memberof tt) then seqblock
			print "---- group in TT ----"
			
			ac := accountConnectivity("credit", fromUnit, fromAccountType) 
			print "AC -> " + ac
			
			//account connectivity test
			if (toAccountType memberof ac) then
				print "---- accounts connected ----"
			else errormessage := "accounts not connected"
		endseqblock
		else errormessage := "group NOT in TT"
	endseqblock
	else errormessage := "Units mismatch"
	
	result := errormessage
endseqblock

//-----------------------------------------------------------------------------------------------------------
//				begin CreditPerformReq
//-----------------------------------------------------------------------------------------------------------
rule CreditPerformReq(transfer, mbr) = 
local fromAccID, fromAccount, fromMbrId, fromProfile, toAccID,
		 limitAlert, bC, amount, error in seq
		 
	print mbr + " -> CreditPerformReq received: " + transfer
	
	//do check the transfer if still ok
	error <- CreditPreviewCheck(transfer, mbr)

	if (error != undef) then
		NotPermitted(transfer, error, mbr)
	else seq
		fromAccID := v(transfer, "from")
		toAccID := v(transfer, "to")
		amount := v(transfer, "amount")
		
		bC := balanceCheck(accountTable(fromAccID), accountTable(toAccID), amount)
		
		if bC = "OK" then seq
			print "---- balance check passed: performing transfer ---"
			
			//TODO: perform transfer
			
			fromAccID := v(transfer, "from")
			fromAccount := accountTable(fromAccID)
			fromMbrId := v(fromAccount, "MemberID")
			fromProfile := profileTable(fromMbrId)
			print "CreditPerformReq: " + "from: " + fromAccID + ", fromMbrId: " + fromMbrId
			
			limitAlert := CheckAccountLimitsAlerts(fromProfile, fromAccount)
			print "Limit Alert: " + limitAlert
			
			//send success message, attach limitAlert if necessary
			Send(TransferPerformedSuccessfully(transfer, limitAlert), mbr)
			
			skip
		endseq
		else NotPermitted(transfer, "Balance check problem: " + bC, mbr)
	endseq	
endseq
//-----------------------------------------------------------------------------------------------------------
//				begin DebitPreviewReq
//-----------------------------------------------------------------------------------------------------------
rule DebitPreviewReq(transfer, mbr) = {
	print mbr + " -> DebitPreviewReq received" + transfer
}

//-----------------------------------------------------------------------------------------------------------
//				begin DebitPerformReq
//-----------------------------------------------------------------------------------------------------------
rule DebitPerformReq(transfer, mbr) = {
	print mbr + " -> DebitPerformReq received" + transfer
}

//-----------------------------------------------------------------------------------------------------------
//				begin main programm
//-----------------------------------------------------------------------------------------------------------
rule Program = {
	forall m in inboxOf(self) do seqblock
		print "message received"
		//fetch message data
		msubject := getMessageSubject(m)
		msgIn := getMessageContent(m)
		member := getMessageSender(m)
		
    	if msgIn != undef and member != undef then seqblock
    		if msubject = "CreditReviewRequest" then CreditPreviewReq(msgIn, member)
    		if msubject = "CreditPerformReq" then CreditPerformReq(msgIn, member)
    		if msubject = "DebitPreviewReq" then DebitPreviewReq(msgIn, member)
    		if msubject = "DebitPerformReq" then DebitPerformReq(msgIn, member)
		endseqblock
    endseqblock
}





rule InitData = {	
	//init profile data
	profileTable("mbrId1") := {
		"lowBalanceAlert" -> 700,
		"highBalanceAlert" -> 1000,		
		"highVolumeAlert" -> 10000,
		"capacity" -> 100000,
		//"saleVolume" -> 100000 //high volumn alert
		"saleVolume" -> 50000 //might be place somewhere else later
	}
	profileTable("mbrId2") := {
		"lowBalanceAlert" -> 700,
		"highBalanceAlert" -> 500,		
		"highVolumeAlert" -> 10000,
		"capacity" -> 100000,		
		"saleVolume" -> 50000 //might be place somewhere else later
	}
	profileTable("mbrId3") := {
		"lowBalanceAlert" -> 1000,
		"highBalanceAlert" -> 700,
		"highVolumeAlert" -> 10000,
		"capacity" -> 100000,		
		"saleVolume" -> 100000 //might be place somewhere else later
	}
	
	
	//init accounts
	accountTable("accId1") := {
		"AccountID" -> "accId1",
		"accountType" -> "CC",
		"MemberID" -> "mbrId1",
		"unit" -> "SRD",
		//"balance" -> toNumber(-9800), //test low balance alert
		//"balance" -> 19900, //test high balance alert
		"balance" -> 8000,
		"creditLimit" -> 10000,
		"creditLimitDate" -> "",
		//"availableBalance" -> 20000, //calculated: balance + creditLimit
		"upperLimit" -> 20000
		//"availableCapacity" -> 100000 //calculated: capacity - salevoulume
	}
	
	accountTable("accId2") := {
		"AccountID" -> "accId2",
		"accountType" -> "CC",
		"MemberID" -> "mbrId2",
		"unit" -> "SRD",
		"balance" -> 10000,
		"creditLimit" -> 10000,
		"creditLimitDate" -> "",
		//"availableBalance" -> 20000, //calculated: balance + creditLimit
		"upperLimit" -> 20000
		//"availableCapacity" -> 100000 //calculated: capacity - salevoulume
	}
	
	accountTable("accId3") := {
		"AccountID" -> "accId3",
		"MemberID" -> "mbrId2",
		"accountType" -> "Income",
		"unit" -> "EUR",
		"balance" -> 1000
		// not defined for "Income" account
		//"creditLimit" -> 10000,
		//"creditLimitDate" -> "",
		//"upperLimit" -> 20000,
		//"availableBalance" -> 20000, //calculated: balance + creditLimit		
		//"availableCapacity" -> 100000
	}
	
	//init user groups
	userGroupTable("mbrId1") := "company"
	userGroupTable("mbrId2") := "company"
	
	//transfer groups
	TT("credit", "SRD", "company") := {"company", "employee", "MNGR", "full"}
	TT("credit", "SRD", "full") := {"company", "employee", "MNGR", "full"}
	TT("credit", "SRD", "MNGR") := {"retail", "company", "employee", "MNGR", "full"}
	TT("credit", "SRD", "employee") := {"retail", "company", "full"}
	TT("credit", "SRD", "consumer_verified") := {"retail", "company", "full"}
	
	forall x in {"retail", "company", "full", "MNGR"} do TT("debit", "SRD", x) := x	
	
	forall x in {"retail", "full"} do TT("debit", "EUR", x) := x  
	
	//account connectivity (Test 2, D3.1)
	//only for user-initiated request, does not include system-initiated requests
	accountConnectivity("credit", "SRD", "CC") := {"CC", "DOMU", "MIRROR"}
	accountConnectivity("credit", "SRD", "DOMU") := {"CC"}
	accountConnectivity("credit", "SRD", "MIRROR") := {"CC"}
	
	accountConnectivity("debit", "SRD", "CC") := {"CC"}
	
	accountConnectivity("debit", "EUR", "Income") := {"Bisoo"}
}