CoreASIM server

use TurboASMPlugin
use Standard

init Start

policy whileRunning = skip
scheduling whileRunning

universe ACCOUNT_TYPES = { CC, DOMU, MIRROR, Income, Prepaid, Bisoo, Topup }
universe OPERATION = { credit, debit }
universe UNIT = {SRD, EUR}
universe USER_TYPE_GROUP = { 
								welcome,
								retail,
								company,
								full,
								employee,
								on_hold,
								MNGR,
								consumer,
								consumer_verified
							}
universe CHANNEL = { Service, POS }

universe MESSAGE_REQUESTS = {
								CreditReviewRequest,
								CreditPerformReq,
								DebitPreviewReq,
								DebitPerformReq,
								DebitAckExec,
								ProceedMessage,
								DoNotProceedMessage,
								TransferPerformed
							}

universe ACCOUNT_ID = {accId1, accId2, accId3}
universe MEMBER_ID = {mbrId1, mbrId2, mbrId3}

controlled profileTable: MEMBER_ID -> MAP
controlled accountTable: ACCOUNT_ID -> MAP
controlled userGroupTable: MEMBER_ID -> USER_TYPE_GROUP
controlled TT: OPERATION * UNIT * USER_TYPE_GROUP -> SET
controlled accountConnectivity: OPERATION * UNIT * ACCOUNT_TYPES -> SET

//-----------------------------------------------------------------------------------------------------------
//				begin tiny logger (because debug logger of ASM-Plugin is laborious to use)
//-----------------------------------------------------------------------------------------------------------
universe LOG_LEVEL = {FATAL, ERROR, WARN, INFO, DEBUG} //all log levels
controlled current_log_level: LOG_LEVEL //current log leve
controlled log_states: SET  //list of states which should be written to the log

rule initCustomLogger(set_log_level) = seq
	//TODO: add log to file option?
	current_log_level := set_log_level
	log_states := {FATAL}
	
	if set_log_level = ERROR then
		log_states := {FATAL, ERROR}
	if set_log_level = WARN then
		log_states := {FATAL, ERROR, WARN}
	if set_log_level = INFO then
		log_states := {FATAL, ERROR, WARN, INFO}
	if set_log_level = DEBUG then
		log_states := {FATAL, ERROR, WARN, INFO, DEBUG}
	
	do_log("LOG_LEVEL: " + current_log_level + ", LOG STATES: " + log_states, DEBUG)
endseq

rule do_log(text, level) = local write_log in seq
	//strangely "= true" needs to be placed
	//otherwise the if-statement fails
	if (level memberof log_states) = true then
		print level + ": " + text
endseq

//-----------------------------------------------------------------------------------------------------------
//				begin globally used rules
//-----------------------------------------------------------------------------------------------------------
rule Start = {
	do_log("ASIM MUTUAL CREDIT server init", INFO)
	
	//defined in initaccounts.casim
	InitData()
	
	//initalize logger
	initCustomLogger(DEBUG)
	
	program(self) := Program
}

//read value from a map (amap) identified by a key
derived v(amap, key) =
	return ret in
		if amap = undef then
			ret := undef
		else
			choose v in amap with key = nth(v, 1) do ret := nth(v, 2)

derived messageContent(msg) =
	return content in
		content := nth(msg, 1)

derived messageSubject(msg) =
	return ms in
		ms := nth(msg, 2)

rule Send(msg, mbr) = {
	send messageContent(msg) to mbr with subject messageSubject(msg)
}

// not permitted message
derived NotPermitted(transfer, error) =
	return message in
		message := [error + " for transfer: " + transfer, toString(DoNotProceedMessage)]

//prepare normal message
derived YouMayProceedWith(transfer) =
	return message in
		message := [transfer, toString(ProceedMessage)]

//success message with optional limitAlert
derived TransferPerformedSuccessfully(transfer, limitAlert) =
	return message in
		if limitAlert = undef then
			message := [transfer + " performed successfully", toString(TransferPerformed)]
		else
			message := [transfer + " performed successfully with alert " + limitAlert,
						toString(TransferPerformed)]

//-----------------------------------------------------------------------------------------------------------
//				begin CreditPreviewReq
//-----------------------------------------------------------------------------------------------------------

rule HandleCreditPreviewReq(transfer, mbr) = local error in seq
	do_log(mbr + " -> CreditPreviewReq received: " + transfer, INFO)
	
	//do check the transfer
	error <- CreditPreviewCheck(transfer, mbr)
	
	//communicate status
	//if seq block is removed send is not performed
	if (error = undef) then seq
		Send(YouMayProceedWith(transfer), mbr)
	endseq 
	else seq
		Send(NotPermitted(transfer, error), mbr)
	endseq
endseq

//check the balances
//maybe derived function instead of returning rule
//amount condition check missing (D2.1)
derived balanceCheck(fromAccount, toAccount, amount) =
	return message in
		if availableBalance(fromAccount) >= amount  and Receivable(amount, toAccount) then
			message := "OK"
		else if availableBalance(fromAccount) < amount then
			message := "ViolatesLowerLimit"
		else if not Receivable(amount, toAccount) then
			message := "ViolatesUpperLimit"
		else //what todo in that case
			message := "UnknownState"

//receivable for to-account
derived Receivable(amt, acc) =
	return pass in
		pass := ((balance(acc) + amt) <= upperLimit(acc))

//get balance for account	
derived balance(acc) =
	return bal in
		bal := v(acc, "balance")
		
//get account upper limit
derived upperLimit(acc) =
	return ul in
		ul := v(acc, "upperLimit")
		
//get credit limit
derived creditLimit(acc) =
	return cl in
		cl :=  v(acc, "creditLimit")

//calualte avaiable balance by using the account
derived availableBalance(account) =
	return availBal in
		availBal := balance(account) + creditLimit(account)

//check alert limits
//  checked after current transfer has
//  been performed on the ledger
derived CheckAccountLimitsAlerts(profile, account) =
	return alert in
		if ((creditLimit(account) + balance(account)) < v(profile, "lowBalanceAlert")) then
			alert := "LowBalanceAlert"
		else if ((upperLimit(account) - balance(account)) < v(profile, "highBalanceAlert")) then
			alert := "HighBalanceAlert"
		else if ((v(profile, "capacity") - v(profile, "saleVolume")) < v(profile, "highVolumeAlert")) then
			alert := "HighVolumeAlert"
		else 
			alert := undef
			
// check for a credit request
// might be party separated for the debit check (similar requirements?)
rule CreditPreviewCheck(transfer, mbr) =
	local errormessage, tt, ac, amount, 
				fromAccID, fromAccount, fromMbrId, fromGrpId, fromUnit, fromAccountType,
				toAccID, toAccount, toMbrId, toGrpId, toUnit, toAccountType, limitAlert, hasCorrectBlance in
seq
	errormessage := undef
	
	// read from properties
	// TODO: create dervied functions for call of
	//       type v(transfer, "from"), e.g. fromAcc(transfer) 
	fromAccID := v(transfer, "from")
	do_log("fromAccID -> " + fromAccID, DEBUG)
	fromAccount := accountTable(fromAccID)
	do_log("fromAccount -> " + fromAccount, DEBUG)
	fromMbrId := v(fromAccount, "MemberID")
	do_log("fromMbrId -> " + fromMbrId, DEBUG)
	fromGrpId := userGroupTable(fromMbrId)
	do_log("fromGrpId -> " + fromGrpId, DEBUG)
	fromUnit := v(fromAccount, "unit")
	do_log("fromUnit -> " + fromUnit, DEBUG)
	fromAccountType := v(fromAccount, "accountType")
	do_log("fromAccountType -> " + fromAccountType, DEBUG)
	
	//read to properties
	toAccID := v(transfer, "to")
	do_log("toAccID -> " + toAccID, DEBUG)
	toAccount := accountTable(toAccID)
	do_log("toAccount -> " + toAccount, DEBUG)
	toMbrId := v(toAccount, "MemberID")
	do_log("toMbrId -> " + toMbrId, DEBUG)
	toGrpId := userGroupTable(toMbrId)
	do_log("toGrpId -> " + toGrpId, DEBUG)
	toUnit := v(toAccount, "unit")
	do_log("toUnit -> " + toUnit, DEBUG)
	toAccountType := v(toAccount, "accountType")
	do_log("toAccountType -> " + toAccountType, DEBUG)
	
	//TODO: raise error on missing information
	
	// checks begin -------------------------------
	// unit check - optional
	if (fromUnit = toUnit) then seq
		do_log("---- units are equal ----", DEBUG)
		
		tt := TT("credit", fromUnit, fromGrpId)
		do_log("TT -> " + tt, DEBUG)
		
		//TT check
		if (toGrpId memberof tt) then seq
			do_log("---- group in TT ----", DEBUG)
			
			ac := accountConnectivity("credit", fromUnit, fromAccountType) 
			do_log("AC -> " + ac, DEBUG)
			
			//account connectivity test
			if (toAccountType memberof ac) then
				do_log("---- accounts connected ----", DEBUG)
			else errormessage := "accounts not connected"
		endseq
		else errormessage := "group NOT in TT"
	endseq
	else errormessage := "Units mismatch"
	
	result := errormessage
endseq

//-----------------------------------------------------------------------------------------------------------
//				begin CreditPerformReq
//-----------------------------------------------------------------------------------------------------------
rule HandleCreditPerformReq(transfer, mbr) = 
local fromAccID, fromAccount, fromMbrId, fromProfile, toAccID,
		 limitAlert, bC, amount, error in seq
		 
	do_log(mbr + " -> CreditPerformReq received: " + transfer, INFO)
	
	//do check the transfer if still ok
	error <- CreditPreviewCheck(transfer, mbr)

	if (error != undef) then
		NotPermitted(transfer, error, mbr)
	else seq
		fromAccID := v(transfer, "from")
		toAccID := v(transfer, "to")
		amount := v(transfer, "amount")
		
		bC := balanceCheck(accountTable(fromAccID), accountTable(toAccID), amount)
		
		if bC = "OK" then seq
			do_log("balance check passed: performing transfer.", INFO)
			
			//TODO: perform transfer
			
			fromAccID := v(transfer, "from")
			fromAccount := accountTable(fromAccID)
			fromMbrId := v(fromAccount, "MemberID")
			fromProfile := profileTable(fromMbrId)
			do_log("CreditPerformReq: " + "from: " + fromAccID + ", fromMbrId: " + fromMbrId, DEBUG)
			
			limitAlert := CheckAccountLimitsAlerts(fromProfile, fromAccount)
			if (limitAlert = undef) then
				do_log("No limit alert", DEBUG)
			else
				do_log("Limit alert: " + limitAlert, WARN)
			
			//send success message, attach limitAlert if necessary
			Send(TransferPerformedSuccessfully(transfer, limitAlert), mbr)
			
			skip
		endseq
		else NotPermitted(transfer, "Balance check problem: " + bC, mbr)
	endseq	
endseq
//-----------------------------------------------------------------------------------------------------------
//				begin DebitPreviewReq
//-----------------------------------------------------------------------------------------------------------
rule HandleDebitPreviewReq(transfer, mbr) = {
	do_log(mbr + " -> DebitPreviewReq received" + transfer, INFO)
}

//-----------------------------------------------------------------------------------------------------------
//				begin DebitPerformReq
//-----------------------------------------------------------------------------------------------------------
rule HandleDebitPerformReq(transfer, mbr) = {
	do_log(mbr + " -> DebitPerformReq received" + transfer, INFO)
}

//-----------------------------------------------------------------------------------------------------------
//				begin DebitPerformReq
//-----------------------------------------------------------------------------------------------------------
rule HandleDebitAckExec(transfer, mbr) = {
	do_log(mbr + " -> DebitAckExec received" + transfer, INFO)
}

//-----------------------------------------------------------------------------------------------------------
//				begin main programm
//-----------------------------------------------------------------------------------------------------------
rule Program = {
	forall m in inboxOf(self) do seq
		do_log("message received", DEBUG)
		
		//fetch message information
		msubject := getMessageSubject(m)
		msgIn := getMessageContent(m)
		member := getMessageSender(m)
		
		//dispatch messages
    	if msgIn != undef and member != undef then seq
    		if msubject = toString(CreditReviewRequest) then HandleCreditPreviewReq(msgIn, member)
    		if msubject = toString(CreditPerformReq) then HandleCreditPerformReq(msgIn, member)
    		if msubject = toString(DebitPreviewReq) then HandleDebitPreviewReq(msgIn, member)
    		if msubject = toString(DebitPerformReq) then HandleDebitPerformReq(msgIn, member)
    		if msubject = toString(DebitAckExec) then HandleDebitAckExec(msgIn, member)
		endseq
    endseq
}