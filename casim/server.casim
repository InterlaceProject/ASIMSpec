CoreASIM server

use Standard

init Start

//include "../../../ASIMSpec/casim/client.casimmod"

scheduling whileRunning

universe ACCOUNT_TYPES = { CC, DOMU, MIRROR, Income, Prepaid, Bisoo, Topup }
universe OPERATION = { credit, debit }
universe USER_TYPE_GROUP = { welcome, retail, company, full, employee, on_hold, MNGR, consumer, consumer_verified }
universe CHANNEL = { Service, POS }
universe METADATA = { null } //TODO

policy whileRunning = skip

rule Start = {
	print "ASIM MUTUAL CREDIT server init"	
	program(self) := Program
}
//-----------------------------------------------------------------------------------------------------------
//				begin globally used rules
//-----------------------------------------------------------------------------------------------------------
// send Response to client
rule Send(response, mbr) = local response_text, response_subject in seq
  pop response_subject from response
  pop response_text from response

  send response_text to mbr with subject response_subject
endseq

//prepare error message
derived ErrorMsg(text) = {
  ["Error", text]
}

// not permitted message
derived NotPermitted(transfer, ttResult) = {
	"Error occured; action not permitted: " + transfer + "; " + ttResult
}

//prepare normal message
derived YouMayProceedWith(transfer) = {
	["YouMayProceedWith", "You may proceed with " + transfer]
}


//-----------------------------------------------------------------------------------------------------------
//				begin CreditPreviewReq
//-----------------------------------------------------------------------------------------------------------
rule CreditPreviewReq(msg, mbr) = {
	print mbr + " -> CreditPreviewReq received: " + msg
	
	//let transfer = msg in //removed Received & Cosumed as mailbox logic slightly different implemented
	//	let ttResult = transferTypeCheck(transfer) in
	//		if ttResult notmemberof TransferType then //swap and invert?
	//			Send(ErrorMsg(NotPermitted(transfer, ttResult)), mbr)
	//		else Send(YouMayProceedWith(transfer), mbr)
}
//where
	//transferTypeCheck
	derived transferTypeCheck(msg) =
	{
		if {tt | tt in TransferType with Match(tt, msg)} != undef then
			{tt | tt in TransferType with Match(tt, msg)}
		else
			powerset(TransferTypeError) //why powerset ???
	}
	//Match
	derived Match(tt, transfer) =
	{
		return match in
			//choose is not defined in D2.1 rules but needed to have the parameters
			//FROM, TO, CHANNEL & CUSTFLDS available for the matching part
			choose c in transfer with "channel" memberof c do let CHANNEL = last(c) in
				choose f in transfer with "from" memberof f do let FROM = last(f) in
					choose t in transfer with "to" memberof t do let TO = last(t) in
					 	choose cf in transfer with "to" memberof cf do let CUSTFLDS = last(cf) in
						 	match := oper(tt) = credit and chan(tt) = CHANNEL and
										owner(FROM) memberof fromMemberGroup(tt) and owner(TO) memberof toMemberGroup(tt) and
										sourceType(tt) = accountType(FROM) and destType(tt) = accountType(TO) and
										custFieldCond(tt, CUSTFLDS) = true
	}

//-----------------------------------------------------------------------------------------------------------
//				begin CreditPerformReq
//-----------------------------------------------------------------------------------------------------------
rule CreditPerformReq(msg, mbr) = {
	print mbr + " -> CreditPerformReq received" + msg
}
//-----------------------------------------------------------------------------------------------------------
//				begin DebitPreviewReq
//-----------------------------------------------------------------------------------------------------------
rule DebitPreviewReq(msg, mbr) = {
	print mbr + " -> DebitPreviewReq received" + msg
}

//-----------------------------------------------------------------------------------------------------------
//				begin DebitPerformReq
//-----------------------------------------------------------------------------------------------------------
rule DebitPerformReq(msg, mbr) = {
	print mbr + " -> DebitPerformReq received" + msg
}

//-----------------------------------------------------------------------------------------------------------
//				begin main programm
//-----------------------------------------------------------------------------------------------------------
rule Program = {
	forall m in inboxOf(self) do seqblock
		//fetch message data
		msubject := getMessageSubject(m)
		msgIn := getMessageContent(m)
		mbr := getMessageSender(m)
		
    	if msgIn != undef and mbr != undef then seqblock
    		if msubject = "CreditReviewRequest" then CreditPreviewReq(msgIn, mbr)
    		if msubject = "CreditPerformReq" then CreditPerformReq(msgIn, mbr)
    		if msubject = "DebitPreviewReq" then DebitPreviewReq(msgIn, mbr)
    		if msubject = "DebitPerformReq" then DebitPerformReq(msgIn, mbr)
		endseqblock
    endseqblock
}
