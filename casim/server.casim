CoreASIM server

use TurboASMPlugin
use Standard

init Start

policy whileRunning = skip
scheduling whileRunning

universe ACCOUNT_TYPES = { CC, DOMU, MIRROR, Income, Prepaid, Bisoo, Topup }
universe OPERATION = { credit, debit }
universe UNIT = {SRD, EUR}
universe USER_TYPE_GROUP = { 
								welcome,
								retail,
								company,
								full,
								employee,
								on_hold,
								MNGR,
								consumer,
								consumer_verified
							}
universe CHANNEL = { Service, POS }

universe MESSAGE_REQUESTS = {
								CreditReviewRequest,
								CreditPerformReq,
								DebitPreviewReq,
								DebitPerformReq,
								DebitAckExec,
								ProceedMessage,
								DoNotProceedMessage,
								TransferPerformed
							}

universe ACCOUNT_ID = {accId1, accId2, accId3}
universe MEMBER_ID = {mbrId1, mbrId2, mbrId3}

controlled profileTable: MEMBER_ID -> MAP
controlled accountTable: ACCOUNT_ID -> MAP
controlled userGroupTable: MEMBER_ID -> USER_TYPE_GROUP
controlled TT: OPERATION * UNIT * USER_TYPE_GROUP -> SET
controlled accountConnectivity: OPERATION * UNIT * ACCOUNT_TYPES -> SET

//-----------------------------------------------------------------------------------------------------------
//				begin tiny logger (because debug logger of ASM-Plugin is laborious to use)
//-----------------------------------------------------------------------------------------------------------
universe LOG_LEVEL = {FATAL, ERROR, WARN, INFO, DEBUG} //all log levels
controlled current_log_level: LOG_LEVEL //current log leve
controlled log_states: SET  //list of states which should be written to the log

rule initCustomLogger(set_log_level) = seq
	//TODO: add log to file option?
	current_log_level := set_log_level
	log_states := {FATAL}
	
	if set_log_level = ERROR then
		log_states := {FATAL, ERROR}
	if set_log_level = WARN then
		log_states := {FATAL, ERROR, WARN}
	if set_log_level = INFO then
		log_states := {FATAL, ERROR, WARN, INFO}
	if set_log_level = DEBUG then
		log_states := {FATAL, ERROR, WARN, INFO, DEBUG}
	
	do_log("LOG_LEVEL: " + current_log_level + ", LOG STATES: " + log_states, DEBUG)
endseq

rule do_log(text, level) = local write_log in seq
	//strangely "= true" needs to be placed
	//otherwise the if-statement fails
	if (level memberof log_states) = true then
		print level + ": " + text
endseq

//-----------------------------------------------------------------------------------------------------------
//				begin globally used rules
//-----------------------------------------------------------------------------------------------------------
rule Start = {
	do_log("ASIM MUTUAL CREDIT server init", INFO)
	
	//defined in initaccounts.casim
	InitData()
	
	//initalize logger
	initCustomLogger(DEBUG)
	
	program(self) := Program
}

//read value from a map (amap) identified by a key
derived v(amap, key) =
	return ret in
		if amap = undef then
			ret := undef
		else
			choose v in amap with key = nth(v, 1) do ret := nth(v, 2)

derived messageContent(msg) =
	return content in
		content := nth(msg, 1)

derived messageSubject(msg) =
	return ms in
		ms := nth(msg, 2)

rule Send(msg, mbr) = {
	send messageContent(msg) to mbr with subject messageSubject(msg)
}

// not permitted message
derived NotPermitted(transfer, error) =
	return message in
		message := [error + " for transfer: " + transfer, toString(DoNotProceedMessage)]

//prepare normal message
derived YouMayProceedWith(transfer) =
	return message in
		message := [transfer, toString(ProceedMessage)]

//success message with optional limitAlert
derived TransferPerformedSuccessfully(transfer, limitAlert) =
	return message in
		if limitAlert = undef then
			message := [transfer + " performed successfully", toString(TransferPerformed)]
		else
			message := [transfer + " performed successfully with alert " + limitAlert,
						toString(TransferPerformed)]

//check the balances
//maybe derived function instead of returning rule
//amount condition check missing (D2.1)
derived balanceCheck(fromAccount, toAccount, amount) =
	return message in
		if (fromAccount = undef or toAccount = undef or amount = undef) then
			message := "Message format incorrect"
		else
			if availableBalance(fromAccount) >= amount  and Receivable(amount, toAccount) then
				message := "OK"
			else if availableBalance(fromAccount) < amount then
				message := "ViolatesLowerLimit"
			else if not Receivable(amount, toAccount) then
				message := "ViolatesUpperLimit"
			else //what todo in that case
				message := "Unknown Stae"

//receivable for to-account
derived Receivable(amt, acc) =
	return pass in
		pass := ((balance(acc) + amt) <= upperLimit(acc))

//get balance for account	
derived balance(acc) =
	return bal in
		bal := v(acc, "balance")
		
//get account upper limit
derived upperLimit(acc) =
	return ul in
		ul := v(acc, "upperLimit")
		
//get credit limit
derived creditLimit(acc) =
	return cl in
		cl :=  v(acc, "creditLimit")
		
//get from account
derived fromAcc(transfer) =
	return fa in
		fa :=  v(transfer, "from") 

//get from account
derived toAcc(transfer) =
	return fa in
		fa :=  v(transfer, "from") 

//return amount
derived amountOf(transfer) =
	return a in
		a := v(transfer, "amount")

//calualte avaiable balance by using the account
derived availableBalance(account) =
	return availBal in
		availBal := balance(account) + creditLimit(account)

//get account set by id		
derived accountOf(accId) =
	return ac in
		ac := accountTable(accId)

//get unit of account id
derived unitOf(accId) =
	return unit in
		unit := v(accountOf(accId), "unit")

//get account type of account id
derived accountType(accId) =
	 return type in
	 	type := v(accountOf(accId), "accountType")

//get owner of account
derived ownerOf(accId) =
	return owner in
		owner := v(accountOf(accId), "MemberID")

//get profile of member
derived profileOf(mbrId) =
	return profile in
		profile := profileTable(mbrId)
		
derived groupOf(mbrId) =
	return group in
		group := userGroupTable(mbrId)

//check alert limits
//  checked after current transfer has
//  been performed on the ledger
derived CheckAccountLimitsAlerts(profile, account) =
	return alert in
		if ((creditLimit(account) + balance(account)) < v(profile, "lowBalanceAlert")) then
			alert := "LowBalanceAlert"
		else if ((upperLimit(account) - balance(account)) < v(profile, "highBalanceAlert")) then
			alert := "HighBalanceAlert"
		else if ((v(profile, "capacity") - v(profile, "saleVolume")) < v(profile, "highVolumeAlert")) then
			alert := "HighVolumeAlert"
		else 
			alert := undef
			
// check for a credit request
// might be party separated for the debit check (similar requirements?)
rule PreviewCheck(fromUnit, toUnit, fromGrpId, toGrpId, fromAccountType, toAccountType, operation) =
local errormessage, tt, ac in seq
	errormessage := undef
	
	// checks begin	
	if (fromUnit = toUnit) then seq // unit check - optional
		do_log("units are equal", DEBUG)
		
		tt := TT("credit", fromUnit, fromGrpId)
		do_log("TT -> " + tt, DEBUG)
		
		if (toGrpId memberof tt) then seq //TT check
			do_log("group in TT", DEBUG)
			
			ac := accountConnectivity(operation, fromUnit, fromAccountType) 
			do_log("AC -> " + ac, DEBUG)
			
			if (toAccountType memberof ac) then //account connectivity test
				do_log("accounts compatible", DEBUG)
			else errormessage := "accounts not compatible"
		endseq
		else errormessage := "group NOT in TT"
	endseq
	else errormessage := "Units mismatch"
	
	result := errormessage
endseq

//-----------------------------------------------------------------------------------------------------------
//				begin CreditPreviewReq
//-----------------------------------------------------------------------------------------------------------

rule HandleCreditPreviewReq(transfer, mbr) = 
	local error in seq
	do_log(mbr + " -> CreditPreviewReq received: " + transfer, INFO)
	
	//do check the transfer if still ok
	error <- PreviewCheck(
		unitOf(fromAcc(transfer)),
		unitOf(toAcc(transfer)),
		groupOf(ownerOf(fromAcc(transfer))),
		groupOf(ownerOf(toAcc(transfer))),
		accountType(fromAcc(transfer)),
		accountType(toAcc(transfer)),
		"credit")
	
	//communicate status
	//if seq block is removed send is not performed
	if (error = undef) then seq
		Send(YouMayProceedWith(transfer), mbr)
	endseq 
	else seq
		Send(NotPermitted(transfer, error), mbr)
	endseq
endseq

//-----------------------------------------------------------------------------------------------------------
//				begin CreditPerformReq
//-----------------------------------------------------------------------------------------------------------
rule HandleCreditPerformReq(transfer, mbr) = 
local limitAlert, bC, error in seq

	// TODO: create dervied functions for call of
	//       type v(transfer, "from"), e.g. fromAcc(transfer) 
	// TODO: raise error on missing information

	do_log(mbr + " :: CreditPerformReq received: " + transfer, INFO)
	
	//do check the transfer if still ok
	error <- PreviewCheck(
		unitOf(fromAcc(transfer)),
		unitOf(toAcc(transfer)),
		groupOf(ownerOf(fromAcc(transfer))),
		groupOf(ownerOf(toAcc(transfer))),
		accountType(fromAcc(transfer)),
		accountType(toAcc(transfer)),
		"credit")

	if (error != undef) then seq
		Send(NotPermitted(transfer, error), mbr)
	endseq
	else seq
		bC := balanceCheck(
			accountOf(fromAcc(transfer)),
			accountOf(toAcc(transfer)),
			amountOf(transfer))

		if bC = "OK" then seq
		
			do_log("balance check passed: performing transfer!", INFO)
		
			//TODO: perform transfer
			
			limitAlert := CheckAccountLimitsAlerts(
				profileOf(ownerOf(fromAcc(transfer))),
				accountOf(fromAcc(transfer)))
			
			if (limitAlert = undef) then
				do_log("No limit alert", DEBUG)
			else
				do_log("Limit alert: " + limitAlert, WARN)
			
			//send success message, attach limitAlert if necessary
			Send(TransferPerformedSuccessfully(transfer, limitAlert), mbr)
			
			skip
		endseq
		else seq
			Send(NotPermitted(transfer, "Balance check problem: " + bC), mbr)
		endseq
	endseq
	
endseq
//-----------------------------------------------------------------------------------------------------------
//				begin DebitPreviewReq
//-----------------------------------------------------------------------------------------------------------
rule HandleDebitPreviewReq(transfer, mbr) = {
	do_log(mbr + " -> DebitPreviewReq received" + transfer, INFO)
}

//-----------------------------------------------------------------------------------------------------------
//				begin DebitPerformReq
//-----------------------------------------------------------------------------------------------------------
rule HandleDebitPerformReq(transfer, mbr) = {
	do_log(mbr + " -> DebitPerformReq received" + transfer, INFO)
}

//-----------------------------------------------------------------------------------------------------------
//				begin DebitPerformReq
//-----------------------------------------------------------------------------------------------------------
rule HandleDebitAckExec(transfer, mbr) = {
	do_log(mbr + " -> DebitAckExec received" + transfer, INFO)
}

//-----------------------------------------------------------------------------------------------------------
//				begin main programm
//-----------------------------------------------------------------------------------------------------------
rule Program = {
	forall m in inboxOf(self) do seq
		do_log("message received", DEBUG)
		
		//fetch message information
		msubject := getMessageSubject(m)
		msgIn := getMessageContent(m)
		member := getMessageSender(m)
		
		//dispatch messages
    	if msgIn != undef and member != undef then seq
    		if msubject = toString(CreditReviewRequest) then HandleCreditPreviewReq(msgIn, member)
    		if msubject = toString(CreditPerformReq) then HandleCreditPerformReq(msgIn, member)
    		if msubject = toString(DebitPreviewReq) then HandleDebitPreviewReq(msgIn, member)
    		if msubject = toString(DebitPerformReq) then HandleDebitPerformReq(msgIn, member)
    		if msubject = toString(DebitAckExec) then HandleDebitAckExec(msgIn, member)
		endseq
    endseq
}