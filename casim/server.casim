CoreASIM server

use Standard

init Start

scheduling whileRunning

controlled c2: INTEGER

//Predefined lists
universe ACCOUNT_TYPES = {fcredit, domu, feeg}
universe OPERATIONS = {credit, debit}
universe MEMBERs = {client, server, somebody}
universe CHANNELs = {phone, website, pos}

universe TransferTypeError = {error}

controlled Identifier: STRING
universe CUSTOM_FIELDS
universe Group

//controlled Formula: ACCOUNT_TYPES //TODO: assumption

controlled name: TransferType -> Identifier
controlled oper: TransferType -> Operation
controlled chan: TransferType -> Channel
controlled sourceType: TransferType -> Formula  //Formula is a function reference (name) to a Boolean function?
controlled destType: TransferType -> Formula
controlled fromMemberGroup: TransferType -> Group
controlled toMemberGroup: TransferType -> Group
controlled amountCond: TransferType -> Formula
controlled custFieldCond: TransferType * CUSTOM_FIELDS -> Formula // different in D2.1 specs

controlled owner: STRING -> AGENTS //TODO: assumption might be different
controlled accountType: STRING -> Formula //TODO: assumption might be different

//all transferetypes by name, filled in Start rule
universe TransferType = {B2BMobile, B2BWebsite, B2BPos}

policy whileRunning = skip

rule Start = {
	print "------------------server init"
	c2 := 0
	program(self) := Program
}

// ------------------------------------------------------------------
//
// Credit and Debit request rules
//
// ------------------------------------------------------------------

// send Response to client
rule Send(response, mbr) = local response_text, response_subject in seq
  pop response_subject from response
  pop response_text from response

  send response_text to mbr with subject response_subject
endseq

//prepare error message
derived ErrorMsg(text) = {
  ["Error", text]
}

// not permitted message
derived NotPermitted(transfer, ttResult) = {
	"Error occured; action not permitted: " + transfer + "; " + ttResult
}

//prepare normal message
derived YouMayProceedWith(transfer) = {
	["YouMayProceedWith", "You may proceed with " + transfer]
}


/* ASM - Template
Symbols 	\in => element of
			!\in => not element of

CreditPreviewReq((channel, from, to, amount, custFlds), mbr) =
	if Received(CreditPreviewReq(credit, channel, from, to, amount, custFlds), from: mbr) then
		let transfer = (credit, channel, from, to, amount, custFlds)
		let ttRes = transferTypeCheck(transfer)
			if ttResult !\in TransferType then
				Send(ErrMsg(NotPermitted(transfer, ttRes)), to: mbr)
			else Send(YouMayProceedWith(transfer), to: mbr)
		Consume(CreditPreviewReq(credit, channel, from, to, amount, custFlds), from: mbr)
	where
		transferTypeCheck(transfer ) \in
			{tt}							if tt \in TransferType and Match(tt , transfer)
			PowerSet(TransferTypeError) 	else
		Match(tt , transfer) if
			oper(tt) = credit and chan(tt) = channel and
			owner(from) (elementof) fromMemberGroup(tt) and owner(to) (elementof) toMemberGroup(tt) and
			sourceType(tt) = accountType(from) and destType(tt) = accountType(to) and
			custFieldCond(tt, custFlds) = true
*/
rule CreditPreviewReq(msg, mbr) =
seq
	print mbr + " -> CreditPreviewReq received: " + msg

	let transfer = msg in //removed Received & Cosumed as mailbox logic slightly different implemented
		let ttResult = transferTypeCheck(transfer) in
			if ttResult notmemberof TransferType then //swap and invert?
				Send(ErrorMsg(NotPermitted(transfer, ttResult)), mbr)
			else Send(YouMayProceedWith(transfer), mbr)
endseq
//where
	//transferTypeCheck
	derived transferTypeCheck(msg) =
	{
		if {tt | tt in TransferType with Match(tt, msg)} != undef then 
			{tt | tt in TransferType with Match(tt, msg)}
		else 
			powerset(TransferTypeError) //why powerset ???
	}
	//Match
	derived Match(tt, transfer) =
	{
		return match in
			//choose is not defined in D2.1 rules but needed to have the parameters
			//FROM, TO, CHANNEL & CUSTFLDS available for the matching part
			choose c in transfer with "channel" memberof c do let CHANNEL = last(c) in
				choose f in transfer with "from" memberof f do let FROM = last(f) in
					choose t in transfer with "to" memberof t do let TO = last(t) in
					 	choose cf in transfer with "to" memberof cf do let CUSTFLDS = last(cf) in
						 	match := oper(tt) = credit and chan(tt) = CHANNEL and
										owner(FROM) memberof fromMemberGroup(tt) and owner(TO) memberof toMemberGroup(tt) and
										sourceType(tt) = accountType(FROM) and destType(tt) = accountType(TO) and
										custFieldCond(tt, CUSTFLDS) = true
	}


/*
CreditPerformReq((channel; from; to; amount; custFlds); mbr) =
	if Received(CreditPerformReq(credit; channel; from; to; amount; custFlds); from: mbr) then
		let transfer = (credit; channel; from; to; amount; custFlds)
		let ttRes = transferTypeCheck(transfer)
			if ttRes \in TransferType then
				Send(ErrMsg(NotPermitted(transfer; ttRes)); to: mbr)
			else let bal = balanceCheck(from; to; amount)
				if bal = OK
				then
					Append(transaction(transfer; ttRes; today); Ledger)
					Send(Confirmed(transfer); to: mbr)
				else Send(ErrMsg(transfer; bal ); to: mbr)
		Consume(CreditPerformReq(channel; from; to; amount; custFlds); from: mbr)
	where
		balanceCheck(from; to; amount) \in { OK } u Powerset(BalanceViolation)
		balanceCheck(from; to; amount) = OK iff amountCond(ttRes)(amount) = true and
			availBalance(from) >= amount and Receivable(amount; to)
		ViolatesAmountCond(amount) if amountCond(ttRes)(amount) = false
		ViolatesLowerLimit(from; amount) if availBalance(from) < amount
		ViolatesUpperLimit(to; amount) if not Receivable(amount; to)
		Receivable(amt; acc) iff balance(acc) + amt <= upperLimit(acc)
*/
rule CreditPerformReq(msg, mbr) = {
	print mbr + " -> CreditPerformReq received" + msg
}

rule DebitPreviewReq(msg, mbr) = {
	print mbr + " -> DebitPreviewReq received" + msg
}

rule DebitPerformReq(msg, mbr) = {
	print mbr + " -> DebitPerformReq received" + msg
}


// ------------------------------------------------------------------
rule Program = seq
	print "------------------tick: " + c2
	print "checking inbox"
	
    choose m in inboxOf(self) with getMessageSubject(m)="CreditReviewRequest" do {
	   	// receive messages
    	msgIn := getMessageContent(m)
    	
    	// when message received call CreditReviewRequest
    	if msgIn != undef then par
    		mbr := getMessageSender(m)
    		print "Got Message: Sender -> " + mbr + "Message -> " + msgIn
    		
    		//CreditPreviewReq(msgIn, mbr)
		endpar
    }
    c2 := c2 + 1
endseq
