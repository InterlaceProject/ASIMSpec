CoreASIM server

use TurboASMPlugin
use Standard

init Start

scheduling whileRunning

universe ACCOUNT_TYPES = { CC, DOMU, MIRROR, Income, Prepaid, Bisoo, Topup }
universe OPERATION = { credit, debit }
universe UNIT = {SRD, EUR}
universe USER_TYPE_GROUP = { welcome, retail, company, full, employee, on_hold, MNGR, consumer, consumer_verified }
universe CHANNEL = { Service, POS }

universe ACCOUNT_ID = {accId1, accId2}
universe MEMBER_ID = {mbrId1, mbrId2}

controlled accountTable: ACCOUNT_ID -> MAP
controlled userGroupTable: MEMBER_ID -> USER_TYPE_GROUP
controlled TT: OPERATION * UNIT * USER_TYPE_GROUP -> SET
controlled accountConnectivity: OPERATION * UNIT * ACCOUNT_TYPES -> SET

policy whileRunning = skip

rule Start = {
	print "ASIM MUTUAL CREDIT server init"
	
	//defined in initaccounts.casim
	InitData()
	
	program(self) := Program
}
//-----------------------------------------------------------------------------------------------------------
//				begin globally used rules
//-----------------------------------------------------------------------------------------------------------
//read value from a map (amap) identified by a key
derived v(amap, key) =
	return ret in
		choose v in amap with key = nth(v, 1) do ret := nth(v, 2)

// not permitted message
rule NotPermitted(transfer, error, mbr) = {
	send error + " for transfer: " + transfer to mbr with subject "DoNotProceedMessage"
}

//prepare normal message
rule YouMayProceedWith(transfer, mbr) = {
	send transfer to mbr with subject "ProceedMessage"
}


//-----------------------------------------------------------------------------------------------------------
//				begin CreditPreviewReq
//-----------------------------------------------------------------------------------------------------------

rule CreditPreviewReq(msg, mbr) = local error in seqblock
	print mbr + " -> CreditPreviewReq received: " + msg
	
	error <- CreditPreviewCheck(msg, mbr)
	
	if (error != undef) then seqblock
		// send DoNotProceedMessage if eror detected
		NotPermitted(msg, error, mbr)
	endseqblock
	else seqblock
		// send ProceedMessage if no eror occured
		YouMayProceedWith(msg, mbr)
	endseqblock
endseqblock

rule CreditPreviewCheck(msg, mbr) =
	local errormessage, tt, ac,
				fromAccID, fromAccount, fromMbrId, fromGrpId, fromUnit, fromAccountType,
				toAccID, toAccount, toMbrId, toGrpId, toUnit, toAccountType in
seqblock
	errormessage := undef
	
	// read from properties
	fromAccID := v(msg, "from")
	print "fromAccID -> " + fromAccID
	fromAccount := accountTable(fromAccID)
	print "fromAccount -> " + fromAccount
	fromMbrId := v(fromAccount, "MemberID")
	print "fromMbrId -> " + fromMbrId
	fromGrpId := userGroupTable(fromMbrId)
	print "fromGrpId -> " + fromGrpId
	fromUnit := v(fromAccount, "unit")
	print "fromUnit -> " + fromUnit
	fromAccountType := v(fromAccount, "accountType")
	print "fromAccountType -> " + fromAccountType
	
	//read to properties
	toAccID := v(msg, "to")
	print "toAccID -> " + toAccID
	toAccount := accountTable(toAccID)
	print "toAccount -> " + toAccount
	toMbrId := v(toAccount, "MemberID")
	print "toMbrId -> " + toMbrId
	toGrpId := userGroupTable(toMbrId)
	print "toGrpId -> " + toGrpId
	toUnit := v(toAccount, "unit")
	print "toUnit -> " + toUnit
	toAccountType := v(toAccount, "accountType")
	print "toAccountType -> " + toAccountType
	
	
	// checks begin -------------------------------
	
	// same unit?
	if (fromUnit = toUnit) then seqblock
		print "---- units are equal ----"
		
		tt := TT("credit", fromUnit, fromGrpId)
		print "TT -> " + tt
		
		//TT check
		if (toGrpId memberof tt) then seqblock
			print "---- group in TT ----"
			
			ac := accountConnectivity("credit", fromUnit, fromAccountType)
			print "AC -> " + ac
			
			//account connectivity test
			if (toAccountType memberof ac) then
				print "---- accounts connected ----"
			else par
				errormessage := "accounts not connected"				
			endpar
		endseqblock
		else par
			errormessage := "group NOT in TT"
		endpar
	endseqblock
	else par
		errormessage := "Units mismatch"
	endpar
	
	result := errormessage
endseqblock

//-----------------------------------------------------------------------------------------------------------
//				begin CreditPerformReq
//-----------------------------------------------------------------------------------------------------------
rule CreditPerformReq(msg, mbr) = {
	print mbr + " -> CreditPerformReq received: " + msg
}
//-----------------------------------------------------------------------------------------------------------
//				begin DebitPreviewReq
//-----------------------------------------------------------------------------------------------------------
rule DebitPreviewReq(msg, mbr) = {
	print mbr + " -> DebitPreviewReq received" + msg
}

//-----------------------------------------------------------------------------------------------------------
//				begin DebitPerformReq
//-----------------------------------------------------------------------------------------------------------
rule DebitPerformReq(msg, mbr) = {
	print mbr + " -> DebitPerformReq received" + msg
}

//-----------------------------------------------------------------------------------------------------------
//				begin main programm
//-----------------------------------------------------------------------------------------------------------
rule Program = {
	forall m in inboxOf(self) do seqblock
		//fetch message data
		msubject := getMessageSubject(m)
		msgIn := getMessageContent(m)
		mbr := getMessageSender(m)
		
    	if msgIn != undef and mbr != undef then seqblock
    		if msubject = "CreditReviewRequest" then CreditPreviewReq(msgIn, mbr)
    		if msubject = "CreditPerformReq" then CreditPerformReq(msgIn, mbr)
    		if msubject = "DebitPreviewReq" then DebitPreviewReq(msgIn, mbr)
    		if msubject = "DebitPerformReq" then DebitPerformReq(msgIn, mbr)
		endseqblock
    endseqblock
}
