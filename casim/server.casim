CoreASIM server

use Standard

init Start

scheduling whileRunning

universe ACCOUNT_TYPES = { CC, DOMU, MIRROR, Income, Prepaid, Bisoo, Topup }
universe OPERATION = { credit, debit }
universe UNIT = {SRD, EUR}
universe USER_TYPE_GROUP = { welcome, retail, company, full, employee, on_hold, MNGR, consumer, consumer_verified }
universe CHANNEL = { Service, POS }

universe ACCOUNT_ID = {accId1, accId2}
universe MEMBER_ID = {mbrId1, mbrId2}

controlled accountTable: ACCOUNT_ID -> MAP
controlled userGroupTable: MEMBER_ID -> USER_TYPE_GROUP
controlled TT: OPERATION * UNIT * USER_TYPE_GROUP -> SET
controlled accountConnectivity: OPERATION * UNIT * ACCOUNT_TYPES -> SET

policy whileRunning = skip

rule Start = {
	print "ASIM MUTUAL CREDIT server init"
	
	//defined in initaccounts.casim
	InitData()
	
	program(self) := Program
}
//-----------------------------------------------------------------------------------------------------------
//				begin globally used rules
//-----------------------------------------------------------------------------------------------------------
//read value from a map (amap) identified by a key
derived v(amap, key) =
	return ret in
		choose v in amap with key = nth(v, 1) do ret := nth(v, 2)

// send Response to client
rule Send(response, mbr) = local response_text, response_subject in seq
  pop response_subject from response
  pop response_text from response

  send response_text to mbr with subject response_subject
endseq

//prepare error message
derived ErrorMsg(text) = {
  ["Error", text]
}

// not permitted message
derived NotPermitted(transfer, ttResult) = {
	"Error occured; action not permitted: " + transfer + "; " + ttResult
}

//prepare normal message
derived YouMayProceedWith(transfer) = {
	["YouMayProceedWith", "You may proceed with " + transfer]
}


//-----------------------------------------------------------------------------------------------------------
//				begin CreditPreviewReq
//-----------------------------------------------------------------------------------------------------------
rule CreditPreviewReq(msg, mbr) = 
		local error, tt, ac,
				fromAccID, fromAccount, fromMbrId, fromGrpId, fromUnit, fromAccountType,
				toAccID, toAccount, toMbrId, toGrpId, toUnit, toAccountType in
seq
	print mbr + " -> CreditPreviewReq received: " + msg
	
	// read from properties
	fromAccID := v(msg, "from")
	print "fromAccID -> " + fromAccID
	fromAccount := accountTable(fromAccID)
	print "fromAccount -> " + fromAccount
	fromMbrId := v(fromAccount, "MemberID")
	print "fromMbrId -> " + fromMbrId
	fromGrpId := userGroupTable(fromMbrId)
	print "fromGrpId -> " + fromGrpId
	fromUnit := v(fromAccount, "unit")
	print "fromUnit -> " + fromUnit
	fromAccountType := v(fromAccount, "accountType")
	print "fromAccountType -> " + fromAccountType
	
	//read to properties
	toAccID := v(msg, "to")
	print "toAccID -> " + toAccID
	toAccount := accountTable(toAccID)
	print "toAccount -> " + toAccount
	toMbrId := v(toAccount, "MemberID")
	print "toMbrId -> " + toMbrId
	toGrpId := userGroupTable(toMbrId)
	print "toGrpId -> " + toGrpId
	toUnit := v(toAccount, "unit")
	print "toUnit -> " + toUnit
	toAccountType := v(toAccount, "accountType")
	print "toAccountType -> " + toAccountType
	
	
	// checks begin -------------------------------
	
	// same unit?
	if (fromUnit = toUnit) then seq
		print "---- units are equal ----"
		
		tt := TT("credit", fromUnit, fromGrpId)
		print "TT -> " + tt
		
		//TT check
		if (toGrpId memberof tt) then seq
			print "---- group in TT ----"
			
			ac := accountConnectivity("credit", fromUnit, fromAccountType)
			print "AC -> " + ac
			
			//account connectivity test
			if (toAccountType memberof ac) then
				print "---- accounts connected ----"
			else par
				error := "accounts not connected"				
			endpar
		endseq
		else par
			error := "group NOT in TT"
		endpar
	endseq
	else par
		error := "Units mismatch"
	endpar
	

	// send ProceedMessage if no eror occured
	if (error = undef) then seq
		send "OK" to mbr with subject "ProceedMessage"
		
		//cannot tell why but without this additional skip
		//the previous message is not sent
		skip
	endseq
	// send DoNotProceedMessage if eror detected
	else seq
		send "ERROR: " + error to mbr with subject "DoNotProceedMessage"		
	endseq
endseq

//-----------------------------------------------------------------------------------------------------------
//				begin CreditPerformReq
//-----------------------------------------------------------------------------------------------------------
rule CreditPerformReq(msg, mbr) = {
	print mbr + " -> CreditPerformReq received" + msg
}
//-----------------------------------------------------------------------------------------------------------
//				begin DebitPreviewReq
//-----------------------------------------------------------------------------------------------------------
rule DebitPreviewReq(msg, mbr) = {
	print mbr + " -> DebitPreviewReq received" + msg
}

//-----------------------------------------------------------------------------------------------------------
//				begin DebitPerformReq
//-----------------------------------------------------------------------------------------------------------
rule DebitPerformReq(msg, mbr) = {
	print mbr + " -> DebitPerformReq received" + msg
}

//-----------------------------------------------------------------------------------------------------------
//				begin main programm
//-----------------------------------------------------------------------------------------------------------
rule Program = {
	forall m in inboxOf(self) do seqblock
		//fetch message data
		msubject := getMessageSubject(m)
		msgIn := getMessageContent(m)
		mbr := getMessageSender(m)
		
    	if msgIn != undef and mbr != undef then seqblock
    		if msubject = "CreditReviewRequest" then CreditPreviewReq(msgIn, mbr)
    		if msubject = "CreditPerformReq" then CreditPerformReq(msgIn, mbr)
    		if msubject = "DebitPreviewReq" then DebitPreviewReq(msgIn, mbr)
    		if msubject = "DebitPerformReq" then DebitPerformReq(msgIn, mbr)
		endseqblock
    endseqblock
}
